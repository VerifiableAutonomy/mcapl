mcapl = ${config_path}

mcapl.classpath=\
	${mcapl}/bin
	
mcapl.sourcepath=\
	${mcapl}/src/classes;\
	${mcapl}/src/examples;\
	${mcapl}/src/tests;
	
mcapl.native_classpath=\
 	${mcapl}/bin

########################### 0. global part ###############################

# do we want JPF exceptions to print their stack traces (that's only for
# debugging)
jpf.print_exception_stack = true

########################### 1. Search part ###############################
search.class = gov.nasa.jpf.search.DFSearch

# This flag indicates whether state matching will only be done when a state
# is revisited at a lower depth. By default this is false. If it is set to
# true and no error is found in a limited-depth search then it is guaranteed
# not to have such error below that depth. Note that for traditional
# depth limited search this does not hold
search.match_depth = false

# This flag indicates whether JPF should produce more than one error
# or stop at the first one
search.multiple_errors = false

# the minimum free memory bounds. If we fall below that threshold, we
# stop the search
search.min_free = 1M

# name of the file in which we store error paths. If not set, we don't store
#search.error_path = error.xml

# the standard properties we want to check for
search.properties=\
gov.nasa.jpf.vm.NotDeadlockedProperty,\
gov.nasa.jpf.vm.NoUncaughtExceptionsProperty


# various heuristic parameters

# This number specifies the maximum number of states to keep on the queue
# during a heuristic search. By default it is set to -1
search.heuristic.queue_limit = -1

# This flag indicates whether branches with counts less than branch-start
# are to be ranked according to how many times they have been taken.
# It is set to true by default. If it is set to false, they are all valued
# the same
search.heuristic.branch.count_early = true

# This number determines at what point branches are heuristically valued as worse
# than non-branching transitions. By default this value is 1.
branch_start = 1


# This number if greater than 0 is returned as the heuristic value for
# non-branching transitions. By default it is set to -1 in which case the
# value of branch-start is returned instead
search.heuristic.branch.no_branch_return = -1

# exclusive search listeners
# search.listener =

################################ 2. VM part ###############################
# this is an ordered list of packages from which we try to locate native peers.

# this is a preemption boundary specifying the max number of instructions after which we
# break the current transition if there are other runnable threads
vm.max_transition_length = MAX

############################### 3. CG part ###############################


# choice randomization policy in effect:
#   "NONE" - choice sets are not randomized
#   "FIXED_SEED" - choice sets are randomized using a fixed seed for each JPF run (reproducible)
#   "VAR_SEED" - choice sets are randomized using a variable seed for each JPF run
cg.randomize_choices = NONE

# the standard seed value used for the FIXED_SEED policy
cg.seed = 42


# if this is set, we create choice generators even if there is only a single
# choice. This is to ensure state storage/matching at all locations where a
# choice generator *could* be created. The default should be to turn it off though,
# since this can produce a lot of additional states (esp. with threads)
cg.break_single_choice = false


# default BooleanChoiceGenerator sequence: do we start with 'false'
cg.boolean.false_first = true

# do we want java.util.Random. nextXX() enumerate choices, or just return a single value?
# (isn't implemented for all types yet)
cg.enumerate_random=true

# maximum number of processors returned by Runtime.availableProcessors(). If this is
# greater than 1, the call represents a ChoiceGenerator
cg.max_processors=1

# creates a CG upon Thread.start, i.e. breaks the starting transition. Note this is
# required for data race detection (which depends on detecting access of shared objects)
cg.threads.break_start=true

# if this option is true, CG is not created when yield() (Thread API)
# is called
cg.threads.break_yield=true

# if this option is true, CG is not created when sleep() (Thread API)
# is called
cg.threads.break_sleep=true

# set if we shold also break on array instructions, e.g. to detect races
# for array elements. This is off by default because it can cause serious
# state explosion
cg.threads.break_arrays=false

# do we support atomic sections. If set to false, Verify.beginAtomic()/endAtomic()
# will not do anything
cg.enable_atomic=true

cg.show_insn=true

############################### 3. Report Part ###############################
log.handler.class=gov.nasa.jpf.util.LogHandler

# Windows seem to have a different default
log.level=warning

report.class=gov.nasa.jpf.report.Reporter
report.publisher=console

report.console.class=gov.nasa.jpf.report.ConsolePublisher

# this prints out repository information if the 'jpf' topic is set (for debugging)
#jpf.report.show_repository=true

#property violation reporting is configured separately
report.console.start=jpf,sut

report.console.transition=
report.console.constraint=constraint,snapshot

report.console.property_violation=error,snapshot
report.console.show_steps=true
report.console.show_method=true
report.console.show_code=false

report.console.finished=result,statistics

#jpf.report.console.show_steps=true
#jpf.report.console.show_method=true
#jpf.report.console.show_code=true

report.xml.class=gov.nasa.jpf.report.XMLPublisher

report.html.class=gov.nasa.jpf.report.HTMLPublisher
report.html.start=jpf,sut,platform,user,dtg,config
report.html.constraint=constraint
report.html.property_violation=
report.html.finished=result,statistics,error,snapshot,output


############################### 4. Listener part #############################

# imperative list of listeners
#listener=

listener.autoload=\
  gov.nasa.jpf.NonNull,\
  gov.nasa.jpf.Const

listener.gov.nasa.jpf.NonNull=gov.nasa.jpf.tools.NonNullChecker
listener.gov.nasa.jpf.Const=gov.nasa.jpf.tools.ConstChecker


### PreciseRaceDetector

# we don't check for races in standard libraries
race.exclude=java.*,javax.*

listener=ajpf.MCAPLListener


############################### 5. test part #############################

test.report.console.finished=result
